// Add at top of file after line 106:
  const [showTaskModal, setShowTaskModal] = useState(false)
  const [editingTask, setEditingTask] = useState<KanbanTask | null>(null)

// Add handleKanbanDragEnd after handleDeleteTask
const handleKanbanDragEnd = async (task: KanbanTask, newStatus: string) => {
  if (!user) return

  try {
    const response = await authFetch('/api/tasks', {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        status: newStatus,
        projectId: projectId,
      }),
    })

    if (!response.ok) {
      const errorText = await response.text()
      console.error('Update task status failed:', response.status, errorText)
      toast({ title: 'Error', description: `Failed to update task status (${response.status})`, variant: 'destructive' })
      return
    }

    const data = await response.json()

    if (data.success) {
      toast({ title: 'Success', description: `Task moved to ${newStatus.replace('_', ' ')}` })
      // Update local state immediately
      setTasks(tasks.map(t => t.id === task.id ? { ...t, status: newStatus as any } : t))
    } else {
      toast({ title: 'Error', description: data.error || data.message || 'Failed to update task status', variant: 'destructive' })
    }
  } catch (error) {
    console.error('Drag and drop error:', error)
    toast({ title: 'Error', description: 'Failed to update task status', variant: 'destructive' })
  }
}

// Add after handleCreateTask:
const handleEditTaskSave = async (taskData: any) => {
  if (!project || !editingTask) return

  try {
    const response = await authFetch(`/api/tasks?id=${editingTask.id}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        title: taskData.title,
        description: taskData.description,
        priority: taskData.priority,
        status: taskData.status,
        projectId: editingTask.projectId || projectId,
        dueDate: taskData.dueDate ? new Date(taskData.dueDate).toISOString() : null,
      }),
    })

    if (!response.ok) {
      const errorText = await response.text()
      console.error('Update task failed:', response.status, errorText)
      toast({ title: 'Error', description: `Failed to update task (${response.status})`, variant: 'destructive' })
      return
    }

    const data = await response.json()

    if (data.success) {
      toast({ title: 'Success', description: 'Task updated successfully' })
      setEditingTask(null)
      setShowTaskModal(false)
      // Update local state immediately for instant feedback
      setTasks(tasks.map(t => t.id === editingTask.id ? { ...editingTask, ...taskData } : t))
    } else {
      toast({ title: 'Error', description: data.error || data.message || 'Failed to update task', variant: 'destructive' })
    }
  } catch (error) {
    console.error('Update task error:', error)
    toast({ title: 'Error', description: 'Failed to update task', variant: 'destructive' })
    }
}

// Add after handleDeleteTask:
const handleDeleteTask = async (taskId: string) => {
  if (!confirm('Are you sure you want to delete this task?')) return

  try {
    const response = await authFetch(`/api/tasks/${taskId}`, {
      method: 'DELETE',
    })

    if (!response.ok) {
      const errorText = await response.text()
      console.error('Delete task failed:', response.status, errorText)
      toast({ title: 'Error', description: `Failed to delete task (${response.status})`, variant: 'destructive' })
      return
    }
    
    const data = await response.json()

    if (data.success) {
      setTasks(tasks.filter(t => t.id !== taskId))
      toast({ title: 'Success', description: 'Task deleted successfully' })
    } else {
      toast({ title: 'Error', description: data.error || 'Failed to delete task', variant: 'destructive' })
    }
  } catch (error) {
    console.error('Delete task error:', error)
    toast({ title: 'Error', description: 'Failed to delete task', variant: 'destructive' })
    }
}

// Add after setEditingTask:
const setEditingTask = (task: KanbanTask | null) => {
  setEditingTask(task)
  setShowTaskModal(true)
}

// Replace handleCreateTask, handleMoveTask, and handleDeleteTask with new implementations
